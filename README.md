1. Какой самый эффективный способ конкатенации строк?

Для этого есть встроенный метод strings.Builder:
```go
var builder strings.Builder
builder.WriteString("Hello, ")
builder.WriteString("world!")
result := builder.String()
```

2. Что такое интерфейсы, как они применяются в Go?

Интерфейсы - это абстрактные объекты, позволяющие нам задать поведение разных объектов, и не привязываться к деталям реализации этих методов. Позволяют достичь полиморфизма. Чем больше интерфейс, тем слабее абстракция.
Пример:
```go
type UserGetter interface {
	GetUser(id int) (any, error)
} 
```

3. Чем отличаются RWMutex от Mutex?

Mutex блокирует канал и для записи и для чтения. RWMutex позволяет блокировать отдельно либо на чтение либо на запись.

4. Чем отличаются буферизированные и не буферизированные каналы?

У небуферизированного канала по умолчанию размер 0, а у буферизированного можно задать размер, что позволяет хранить в нем больше одного элемента.

5. Какой размер у структуры struct{}{}?

Размер такой структуры равен 0, поскольку на размер структуры влияют её поля.

6. Есть ли в Go перегрузка методов или операторов?

В golang отсутствует перегрузка методов или операторов.

7. В какой последовательности будут выведены элементы map[int]int?

Пример:
m[0]=1
m[1]=124
m[2]=281

Ответ: в мапе элементы хранятся неуподрядочены, то есть хранятся в случайном порядке. Поэтому нельзя точно сказать, в каком порядке будут выведены элементы.


8. В чем разница make и new?

make нужен для создания сложных структур, таких как chan, slice, array, map 
а new позволяет создавать все.

9. Сколько существует способов задать переменную типа slice или map?

```go
var first []string
second := []string{}
fourth := make([]string, 0)
third := new([]string)

var first map[int]int
second := map[string]int{}
fourth := make(map[string]int)
third := new(map[string]int)
```

10. Что выведет данная программа и почему?


func update(p *int) {
  b := 2
  p = &b
}
func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}

Ответ: 1 1
в функции update() меняется значение указателя, а не значение, на которое указывает указатель.


11. Что выведет данная программа и почему?


func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}

Ответ: 0..4 в рандомном порядке, далее deadlock, т.к. в горутину передан WaitGroup, а не указатель на него

12. Что выведет данная программа и почему?


func main() {
  n := 0
  if true {
  	n := 1
    n++
  }
  fmt.Println(n)
}

Ответ: программа выведет 0, так как мы в локальном скоупе создали новую переменную n.


13. Что выведет данная программа и почему?


func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}

Ответ: 
    
    [100 2 3 4 5]
    При append создается новый slice


14. Что выведет данная программа и почему?


func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}

Ответ: 

	[b b a][a a]
	slice в анонимной функции перекрывает slice в main, обновляется и выводится [b b a], slice в main не изменялся - выводится [a a]